function modelAndDataComparison(proteinData, generationNaive, naiveProteinModel, generationImproved, improvedProteinModel)
%Function returns models of paperData, naiveProteinModel, and
%improvedProtein Model superimposed

%plot(CFPSponge(:, 1), CFPSponge(:, 2), 'r.'); hold on
%plot MODELS HERE

%legend('CFP with Sponge', 'Model');

readIn = dlmread(proteinData);

%shift data
shiftedProteinData(:, 2) = readIn(:, 2) - mean(readIn(:, 2));
%Note: didn't smooth since reverse-engineered data are single pts
[pmax, iDataMax] = extrema(shiftedProteinData);

proteinFirstMax = min(iDataMax);

%process protein model for maxima
[naiveProteinMaxima, naiveProteinIndices] = findProteinModelMaxima(naiveProteinModel);
[improvedProteinMaxima, improvedProteinMaxIndices] = findProteinModelMaxima(improvedProteinModel);

%find first max > datamax
mimax = naiveProteinIndices(naiveProteinIndices > proteinFirstMax);

firstMaxGreaterThanDataMax = min(mimax);

%line up maxima
ndat = length(readIn(:, 1));

firstpoint = mimax - proteinFirstMax + 1;

lastpoint = mimax - proteinFirstMax + ndat;

%get model points corresponding to data points to line up
modelShifted = proteinModel(firstpoint : lastpoint);

%start at 0

model_t = model_t - model_t(1);

 

%line up maxima

function linedUp = lineUpMaxima(data)

ndat = length(dat(:. 1));

firstpoint = mimax

 

%ttest each model using code that I submitted (sponge v nonsponge)

%[is_sig, pval] = kstest2(xx, yy)

 


%Sort the maxima by the order of when they occur, not how high they are.
%Thus, sort by the maxima indices.
[~, j] = sort(maxima_idx_tetR);
maxima_idx_tetR = maxima_idx_tetR(j);
maxima_tetR = maxima_tetR(j);

figure; 
plot(generation, tetR,'.-r',maxima_idx_tetR,maxima_tetR,'kx');

for mm=1:length(maxima_idx_tetR)-1
    period(mm) = maxima_idx_tetR(mm+1)-maxima_idx_tetR(mm);
end
%discard transients
period = period(period>5);

%mean and standard deviation for comparison
mean_period = mean(period);
std_period = std(period);
%mean amplitude of oscillations is just:
mean_amp = mean(maxdat_tetR);
 

